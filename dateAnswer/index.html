<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dance Yes or No Plinko</title>
  

  <!--<link rel="icon" href="/favicon.ico">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">-->

  <link rel="stylesheet" href="styles.css">

</head>

<body>
  <!-- your content here... -->
  <h1 class="top-text">Welcome, Brooke!!!</h1>
  <h1>Drop the ball into each hole to get the answer.</h1>
  <h1>Use the buttons to move the starting location of the ball.</h1>
  <script src="matter.js"></script>

  <p class="direction-buttons">
    <button id="leftButton" class="move-button">←</button>
    <button id="rightButton" class="move-button">→</button>
  </p>

  <p class="control-container">
    <button id="goButton" class="control-button">Drop Ball</button>
    <button id="refreshButton" class="control-button">Reset Ball</button>
  </p>
  <p class="img-center">
    <img src="images/valentines.jpg" alt="valentinesPoster" id="resultImage"/>
  </p>
  <p class="canvas-container"></p>
  <script>
    // module aliases
    var Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Body = Matter.Body,
        Composite = Matter.Composite,
        Mouse = Matter.Mouse,
        MouseConstraint = Matter.MouseConstraint,
        Events = Matter.Events;

    var defaultCategory = 0x0001,
    ballCategory = 0x0002,
    pegCategory = 0x0004,
    goalCategory = 0x0008;

    // create an engine
    var engine = Engine.create();

    // create a renderer
    var render = Render.create({
        element: document.querySelector(".canvas-container"),
        engine: engine,
    });
    render.options.wireframes = false;
    // create two boxes and a ground
    var boxA = Bodies.rectangle(400, 200, 80, 80);
    var boxB = Bodies.rectangle(450, 50, 80, 80);

    var circle = Bodies.circle(400, 25, 25, {
      friction: .001,
      restitution: 0,
      collisionFilter: {
        category: ballCategory
      },
      render: {
        fillStyle: "#FF3C33"
      }
    });

    var ground = Bodies.rectangle(400, 610, 810, 60, {friction: .001, isStatic: true, render: {fillStyle: "#0000ff", lineWidth: 1} });
    var ceiling = Bodies.rectangle(400, -20, 810, 60, { friction: .001, isStatic: true, render: {fillStyle: "#0000ff", lineWidth: 1} });
    var ledge = Bodies.rectangle(400, 80, 810, 10, { friction: .001, isStatic: true, render: {fillStyle: "#0000ff", lineWidth: 1} });
    var leftWall = Bodies.rectangle(-20, 300, 60, 610, { friction: .001, isStatic: true, render: {fillStyle: "#0000ff", lineWidth: 1} });
    var rightWall = Bodies.rectangle(820, 300, 60, 610, { friction: .001, isStatic: true, render: {fillStyle: "#0000ff", lineWidth: 1} });

    var bounds = [ledge, ceiling, leftWall, rightWall];
    var running = false;

    var succesFlags = [false, false, false, false, false, false];

    Composite.add(engine.world, bounds);

    let objectArray = [];

    for(let i = 0; i < 4; i++) {
      for (let j = 0; j < ((i % 2 ==0) ? 6 : 7); j++) {
        let toAdd = Bodies.circle( ((i % 2 == 0) ? (600 / 10) : 0) + 35 + j * (600 / 5),  105 + i * (700 / 8), 15, {
          isStatic : true, 
          friction: .001,
          restitution: 1,
          collisionFilter: {
            category: pegCategory
          },
          render : {
            fillStyle: "#BA8C63"
          }
        });
        objectArray.push(toAdd);
      }
    }

    for(let i = 0; i < 5; i++) {
      let toAdd = Bodies.rectangle((i + 1) * (800 / 6), 550 , 10, 75, {
        isStatic: true,
        render: {
          fillStyle: "#0000ff"
        }
      });
      objectArray.push(toAdd);
    }

    let goalImages = [
      "images/y.png",
      "images/e.png",
      "images/s.png",
      "images/!.png",
      "images/!.png",
      "images/!.png"
    ];

    let sensors = [];
    for(let i = 0; i < 6; i++) {
      let toAdd = Bodies.rectangle(((i * 2) + 1) * (800 / 12), 575 , (800 / 6) - 20, 50, {
        isStatic: true,
        isSensor: true,
        render: {
          fillStyle: "transparent",
          sprite: {
            xScale: .15,
            yScale: .15,
            yOffset: .15
          }
        },
        collisionFilter: {
          category: goalCategory
        }
      });
      sensors.push(toAdd);
      objectArray.push(toAdd);
    }
    

    objectArray.push(circle);
    
    objectArray.push(ground);
    
    // add all of the bodies to the world
    Composite.add(engine.world, objectArray);

    // run the renderer
    Render.run(render);

    // create runner
    var runner = Runner.create();

    // run the engine
    Runner.run(runner, engine);

    document.getElementById("goButton").addEventListener("click", () => {
      Composite.remove(engine.world, ledge);
      circle.restitution = 1;
      running = true;
    });
    
    Events.on(engine, 'collisionStart', function(event) {
        var pairs = event.pairs;
        
        for (var i = 0, j = pairs.length; i != j; ++i) {
            var pair = pairs[i];
            if (pair.bodyA === circle) {
              let bodyB = pair.bodyB;
                if(pair.bodyB === sensors[0]) {
                  bodyB.render.sprite.texture = goalImages[0];
                  circle.restitution = 0;
                  succesFlags[0] = true;
                }
                if(pair.bodyB === sensors[1]) {
                  bodyB.render.sprite.texture = goalImages[1];
                  circle.restitution = 0;
                  succesFlags[1] = true;
                }
                if(pair.bodyB === sensors[2]) {
                  bodyB.render.sprite.texture = goalImages[2];
                  circle.restitution = 0;
                  succesFlags[2] = true;
                }
                if(pair.bodyB === sensors[3]) {
                  bodyB.render.sprite.texture = goalImages[3];
                  circle.restitution = 0;
                  succesFlags[3] = true;
                }
                if(pair.bodyB === sensors[4]) {
                  bodyB.render.sprite.texture = goalImages[4];
                  circle.restitution = 0;
                  succesFlags[4] = true;
                }
                if(pair.bodyB === sensors[5]) {
                  bodyB.render.sprite.texture = goalImages[5];
                  circle.restitution = 0;
                  succesFlags[5] = true;
                }
            } 
            else if (pair.bodyB === circle) {
                let bodyA = pair.bodyA;
                if(pair.bodyA === sensors[0]) {
                  bodyA.render.sprite.texture = goalImages[0];
                  circle.restitution = 0;
                  succesFlags[0] = true;
                }
                if(pair.bodyA === sensors[1]) {
                  bodyA.render.sprite.texture = goalImages[1];
                  circle.restitution = 0;
                  succesFlags[1] = true;
                }
                if(pair.bodyA === sensors[2]) {
                  bodyA.render.sprite.texture = goalImages[2];
                  circle.restitution = 0;
                  succesFlags[2] = true;
                }
                if(pair.bodyA === sensors[3]) {
                  bodyA.render.sprite.texture = goalImages[3];
                  circle.restitution = 0;
                  succesFlags[3] = true;
                }
                if(pair.bodyA === sensors[4]) {
                  bodyA.render.sprite.texture = goalImages[4];
                  circle.restitution = 0;
                  succesFlags[4] = true;
                }
                if(pair.bodyA === sensors[5]) {
                  bodyA.render.sprite.texture = goalImages[5];
                  circle.restitution = 0;
                  succesFlags[5] = true;
                }
              }
            }
            let showImg = true;
            for(let i = 0; i < succesFlags.length; i++) {
              if(!succesFlags[i]) {
                showImg = false;
                break;
              }
            }
            if(showImg) {
              document.getElementById("resultImage").style.display = "unset";
            }
    });
    document.getElementById("leftButton").addEventListener("click", (e) => {
      if(!running)
      Body.applyForce(circle, circle.position, Matter.Vector.create(-.004 * circle.mass, 0));
    });
    document.getElementById("rightButton").addEventListener("click", (e) => {
      if(!running)
      Body.applyForce(circle, circle.position, Matter.Vector.create(.004 * circle.mass, 0));
    });
  </script>
  <script>
    // set refresh button
    document.getElementById("refreshButton").addEventListener("click", () => {
      Body.setPosition(circle, Matter.Vector.create(400, 25));
      Body.set(circle, {
        friction: .001,
        restitution: 0
      });
      circle.collisionFilter.mask = defaultCategory | goalCategory | pegCategory;
      running = false;
      Composite.add(engine.world, ledge);
    });
  </script>
  
</body>
</html>